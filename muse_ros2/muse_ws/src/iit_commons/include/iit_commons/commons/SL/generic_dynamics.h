
#include "SL.h"

#include "joint_status_conversion.h"
#include "rbd_conversion.h"

#include <Eigen/Dense>
#include <iit/rbd/rbd.h>

namespace iit {
namespace commons {
namespace SL {

namespace internal {


template<class ROBOT>
struct RobotTypes {
    typedef typename dog::JointState JointState;
    typedef typename ROBOT::FwdDynEngine FwdDynEngine;
    typedef typename ROBOT::InvDynEngine InvDynEngine;
    typedef typename iit::commons::SL::SLtoRobogen<ROBOT> SLtoRGen;
    typedef typename iit::commons::SL::RobogenToSL<ROBOT> RGenToSL;
};


} // namespace internal



/**
 * Simple generic container of common code to compute the forward dynamics,
 * within SL, using a Robcogen-generated engine.
 *
 * The template parameter is the traits class of a robot, as generated by
 * Robcogen.
 *
 * The static methods require an instance of the actual forward dynamics
 * engine for the robot, ie the class generated by Robcogen.
 *
 * \ingroup robcogen-sl
 */
template<class ROBOT>
struct forward_dynamics
{
    private:
        typedef typename internal::RobotTypes<ROBOT> Types;
    public:
    /*!
     * Computes the forward dynamics of a fixed-base robot, using the given
     * engine.
     *
     * @param fwddyn a forward dynamics object for the robot
     *
     * Original SL documentation about parameters:
     * @param lstate the state containing th, thd, thdd, and receiving the
     *                appropriate u
     */
    static void fixed_base(
            typename Types::FwdDynEngine& fwddyn,
            const typename Types::FwdDynEngine::ExtForces& fext,
            SL_Jstate* lstate)
    {
        //static_assert(!ROBOT::floating_base, "You are invoking the fixed base forward dynamics on a floating base robot");
        static typename Types::JointState q, qd, qdd, tau;
        Types::SLtoRGen::pos_vel(lstate, q, qd);
        Types::SLtoRGen::u(lstate, tau);

        fwddyn.fd(qdd, q, qd, tau, fext);
        Types::RGenToSL::acc(qdd, lstate);
    }
    /*!
     * Computes the forward dynamics of a floating-base robot, using the given
     * engine.
     *
     * @param[in] fwddyn an instance of the forward dynamics generated by
     *            RobCoGen for the robot
     * @param[in] extForces the external wrenches acting on the links, each
     *    expressed in the link frame
     * @param[in] world_R_base a 3x3 rotation matrix from base coordinates to
     *   world coordinates (this matrix carries the information about the
     *   attitude of the floating base)
     *
     * The SL parameters (adapted from the original documentation):
     * @param[in,out] lstate the state containing th, thd, thdd, and receiving the
     *                appropriate u
     * @param[in,out] cbase the position state of the base
     * @param[in,out] obase the orientation state of the base
     *
     * The input kinematic state of the base is read from \c cbase and \c obase,
     * which will receive the computed acceleration.
     */
    template<class MX>
    static void floating_base(
            typename Types::FwdDynEngine& fwddyn,
            const typename Types::FwdDynEngine::ExtForces& extForces,
            const Eigen::MatrixBase<MX>& world_R_base,
            SL_Jstate* lstate,
            SL_Cstate* cbase,
            SL_quat*   obase)
    {
        static typename Types::JointState q, qd, qdd, tau;
        static typename Types::FwdDynEngine::Acceleration trunk_a, trunk_a_world, gravity(Types::FwdDynEngine::Acceleration::Zero());
        static typename Types::FwdDynEngine::Velocity trunk_v, trunk_v_world;

        Types::SLtoRGen::pos_vel(lstate, q, qd);
        Types::SLtoRGen::u(lstate, tau);
        baseVelFromSL(*cbase, *obase, trunk_v_world);

        // For the state of the floating base, SL uses Euclidean vectors in
        // world coordinates. RobCoGen uses spatial vectors in base coordinates.
        // Therefore a few conversions must be applied. See comments below.

        // Rotate the velocity from world to base coordinates, before passing it
        // to the RobCoGen forward dynamics
        iit::rbd::linearPart(trunk_v)  = world_R_base.transpose() * iit::rbd::linearPart(trunk_v_world);
        iit::rbd::angularPart(trunk_v) = world_R_base.transpose() * iit::rbd::angularPart(trunk_v_world);

        iit::rbd::linearPart(gravity) = - iit::rbd::g *
                world_R_base.transpose().col(iit::rbd::Z);
        fwddyn.fd(qdd, trunk_a, trunk_v, gravity, q, qd, tau, extForces);
        Types::RGenToSL::acc(qdd, lstate);

        // This terms accounts for the difference between spatial acceleration
        // and the euclidean linear acceleration. See Roy's publication for
        // more information. In legacy SL, Mathematica-generated code also
        // contains this correction.
        iit::rbd::Vector3d afix = iit::rbd::angularPart(trunk_v).cross(iit::rbd::linearPart(trunk_v));

        // Rotate the base acceleration in world frame, then copy it to SL var
        iit::rbd::linearPart(trunk_a_world) =
                world_R_base * ( iit::rbd::linearPart(trunk_a) + afix );
        iit::rbd::angularPart(trunk_a_world) =
                world_R_base * iit::rbd::angularPart(trunk_a);
        baseAccelToSL(trunk_a_world, *cbase, *obase);
    }
};

/**
 * Simple generic container of common code to compute the inverse dynamics,
 * within SL, using a Robcogen-generated engine.
 *
 * The template parameter is the traits class of a robot, as generated by
 * Robcogen.
 *
 * The static methods require an instance of the actual inverse dynamics
 * engine for the robot, ie the class generated by Robcogen.
 *
 * \ingroup robcogen-sl
 */
template<class ROBOT>
struct inverse_dynamics
{
    private:
        typedef typename internal::RobotTypes<ROBOT> Types;
    public:
    /*!
     * Computes the inverse dynamics of a fixed-base robot, using the given
     * engine.
     *
     * @param invdyn an inverse dynamics object for the given robot
     *
     * Original SL documentation about parameters:
     * @param cstate the current state (pass NULL to use only desired state)
     * @param lstate the desired state
     */
    static void fixed_base(
        typename ROBOT::InvDynEngine& invdyn,
        SL_Jstate*  cstate,
        SL_DJstate* lstate)
    {
        //static_assert(!ROBOT::floating_base, "You are invoking the fixed base inverse dynamics on a floating base robot");
        static typename Types::JointState q, qd, qdd, tau;
        if(cstate == NULL) {
            Types::SLtoRGen::pos_vel_acc(lstate, q, qd, qdd);
        } else {
            Types::SLtoRGen::pos_vel(cstate, q, qd);
            Types::SLtoRGen::acc(lstate, qdd);
        }
        invdyn.id(tau, q, qd, qdd);
        Types::RGenToSL::uff(tau, lstate);
    }

    /*!
     * Computes the inverse dynamics of a floating-base robot, using the given
     * engine.
     *
     * @param invdyn an inverse dynamics object for the given robot
     * @param world_R_base a 3x3 rotation matrix from base coordinates to
     *   world coordinates (this matrix carries the information about the
     *   attitude of the floating base)
     *
     * Documentation of SL parameters (adapted from the original comments)
     * @param cstate the current state (pass NULL to use only desired state)
     * @param lstate the desired state
     * @param cbase the position state of the base (input and output)
     * @param obase the orientation state of the base (input and output)
     */
    template<class MX>
    static void floating_base(
            typename ROBOT::InvDynEngine& invdyn,
            const Eigen::MatrixBase<MX>& world_R_base,
            SL_Jstate*  cstate,
            SL_DJstate* lstate,
            SL_Cstate* cbase,
            SL_quat*   obase)
    {
        static typename Types::JointState q, qd, qdd, tau;
        static typename Types::InvDynEngine::Velocity trunk_v;
        static typename Types::InvDynEngine::Acceleration trunk_a,
              trunk_a_world, gravity(Types::InvDynEngine::Acceleration::Zero());

        if(cstate == NULL) {
            Types::SLtoRGen::pos_vel_acc(lstate, q, qd, qdd);
        } else {
            Types::SLtoRGen::pos_vel(cstate, q, qd);
            Types::SLtoRGen::acc(lstate, qdd);
        }

        baseVelFromSL(*cbase, *obase, trunk_v);

       rbd::linearPart(gravity) = - iit::rbd::g *
                world_R_base.transpose().col(iit::rbd::Z);

       invdyn.id(tau, trunk_a, gravity, trunk_v, q, qd, qdd);
       Types::RGenToSL::uff(tau, lstate);

       // Rotates the base acceleration in world frame, then copy it to SL
       iit::rbd::linearPart(trunk_a_world)  = world_R_base * iit::rbd::linearPart(trunk_a);
       iit::rbd::angularPart(trunk_a_world) = world_R_base * iit::rbd::angularPart(trunk_a);
       baseAccelToSL(trunk_a_world, *cbase, *obase);
    }

};




}
}
}


